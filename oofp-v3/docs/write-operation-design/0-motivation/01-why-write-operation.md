# 為什麼選擇 `WriteOperation`

在多數系統中，資料轉換往往是以「流程」或「步驟」的形式被描述。

一開始看起來合理，但隨著需求累積，系統會逐漸出現一個熟悉的現象：

> 我們能看懂流程，  
> 卻越來越難說清楚「到底做了哪些改變」。

這份設計，正是從這個不安開始的。

---

## 問題不在於流程，而在於語言

常見的轉換設計，通常會落在以下幾種形式：

- step-by-step pipeline
- handler chain
- command / handler
- service method orchestration

它們的共同特徵是：

- 行為被包在「流程節點」中
- 語意隨著順序與條件分散
- 推理時必須「跑一遍流程」才能理解結果

當系統變複雜後，  
我們理解的其實不是「行為」，而是「執行路徑」。

---

## 寫入，才是真正發生變化的地方

無論流程設計得多麼精巧，  
真正改變系統狀態的，始終只有一件事：

> **某個值，被寫入了某個地方。**

這個事實往往被各種抽象掩蓋：

- setter 被包進 service
- entity 被包進 aggregate
- 邏輯被包進 pipeline

結果是：
- 我們很難單獨討論「這次寫入本身是否合理」
- 更難重用或重組這個寫入行為

---

## `WriteOperation` 的核心立場

`WriteOperation` 的出發點非常單純：

> **把「寫入這個動作」從流程中抽離，  
> 成為一個可以被命名、被組合、被推理的語言單位。**

在這個設計中：

- `WriteOperation` 只描述「對 `target` 做了什麼改變」
- 不描述：
  - 從哪裡來
  - 什麼時候執行
  - 執行順序為何

這些都不是寫入行為本身的責任。

---

## 為什麼不是 Step

Step 看似是合理的抽象，但它通常會承載太多東西：
- 條件判斷
- 流程控制
- 前後相依
- 副作用

久而久之，Step 不再只是「一步」，  
而是「一段小流程」。

`WriteOperation` 則刻意避免這件事：
- 它沒有前後文
- 沒有流程意識
- 甚至不關心是否成功或失敗

它只關心一件事：  
**這個 target 被怎麼改變。**

---

## 語言選擇，而不是技術技巧

選擇 `WriteOperation`，  
不是為了少寫幾行程式碼，  
而是為了建立一種不同的描述方式。

這是一種「語言層級」的選擇：

- 我們先描述行為
- 再決定如何組裝
- 最後才決定如何執行

而不是反過來。

---

## 為什麼這件事值得被嚴肅對待

當寫入行為被視為一等公民時：
- 行為可以被比較
- 可以被合併或替換
- 可以被條件化
- 可以被測試，而不依賴整個流程

更重要的是：

> **系統的複雜度，會集中在語言本身，  
> 而不是散落在流程的各個角落。**

---

## 接下來要談的是什麼

在理解為什麼 `WriteOperation` 是核心之後，  
下一步要釐清的是：

- `WriteOperation` 究竟「是什麼、不是什麼」
- 它的責任邊界應該畫在哪裡

這會是下一章要處理的主題。

