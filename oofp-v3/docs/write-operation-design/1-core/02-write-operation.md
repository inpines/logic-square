# `WriteOperation` 是什麼、不是什麼

在前一章中，我們說明了為什麼要把「寫入行為」從流程中抽離出來，
成為一個獨立的語言單位。

這一章要進一步回答一個更精確的問題：

> **當我們說 `WriteOperation` 是核心時，  
> 我們究竟在承諾它什麼責任，又刻意拒絕它承擔什麼？**

---

## `WriteOperation` 是什麼

`WriteOperation` 的定義，可以濃縮成一句話：

> **`WriteOperation` 描述一次「對目標物件狀態的改變」。**

它關注的只有一件事：
- 某個 target
- 在這個操作之後
- 與之前有了什麼不同

因此，`WriteOperation` 具有以下特徵。

---

### 1. 它是「行為描述」，不是流程節點

`WriteOperation` 不代表：
- 第幾步
- 什麼時候執行
- 前後還有誰

它只是一段可被呼叫的行為描述。

是否要執行、何時執行、執行幾次，
都不屬於 `WriteOperation` 的責任。

---

### 2. 它必須是可單獨推理的

一個 `WriteOperation` 應該能被獨立理解：
- 單看這個操作，就知道它會改變什麼
- 不需要閱讀整個 pipeline 才能理解其效果

如果一個操作：
- 需要仰賴前一個操作的隱含狀態
- 或假設自己一定出現在某個流程位置

那它其實已經不是一個好的 `WriteOperation`。

---

### 3. 它只關心「寫入」，不關心「來源」

`WriteOperation` 不負責回答：

- 值是從哪裡來的
- 是使用者輸入、查詢結果，還是計算值
- 是否來自外部系統

這些問題屬於：
- query
- context
- orchestration

`WriteOperation` 只在意：
> **當我被呼叫時，我要如何改變 target。**

---

## `WriteOperation` 不是什麼

理解 `WriteOperation` 的邊界，
往往比理解它的能力更重要。

以下是這個設計刻意排除的責任。

---

### 1. 它不是驗證器（`Validator`）

`WriteOperation` 不應該負責：
- 檢查資料是否合法
- 決定是否允許寫入
- 收集錯誤訊息

一旦驗證邏輯被塞進 `WriteOperation`，
寫入行為就會開始變得條件化、不穩定。

驗證應該在寫入之前完成，
而不是與寫入混在同一個語言單位中。

---

### 2. 它不是流程控制者

`WriteOperation` 不應該包含：
- if / else
- 分支邏輯
- retry / fallback

這些邏輯一旦進來，
`WriteOperation` 就會退化成「小型流程」。

流程屬於 orchestration，
不是行為語言的一部分。

---

### 3. 它不是結果轉換器

`WriteOperation` 的目的不是產生結果物件：
- 不負責組 `Response`
- 不負責 `DTO mapping`
- 不負責 `ViewModel` 建構

這些屬於 transform 階段。

`WriteOperation` 的產物，
永遠只是「被改變過的 target」。

---

## 為什麼這樣的邊界是必要的

如果不刻意畫出這些邊界，
系統通常會朝向以下方向演化：
- 寫入與驗證混雜
- 行為與流程糾纏
- 單一操作難以重用
- 改一個需求就必須理解整條 pipeline

透過限制 `WriteOperation` 的責任，
複雜度會被迫往外移動，
集中到：
- 組裝規則
- 條件選擇
- 執行時機

而不是藏在行為本身。

---

## 一個刻意保守的設計選擇

從某個角度來看，
`WriteOperation` 是一個「能力被壓縮過的抽象」。

它不聰明，
也不試圖解決所有問題。

但正因如此：
- 它可以被大量組合
- 可以被反覆使用
- 可以在不同流程中被重放

這正是它被選為核心語言的原因。

---

## 下一章要談的是什麼

當 `WriteOperation` 被定義為「最小行為單位」之後，
接下來的問題自然會是：

> **如果 `WriteOperation` 只負責行為描述，  
> 那誰來負責把這些行為組起來？**

下一章將聚焦在這個角色上：
**`GeneralBuilder`**。

