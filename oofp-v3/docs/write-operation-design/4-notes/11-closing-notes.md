# 收尾說明：為什麼要把這套設計寫下來

這份文件從來不是為了介紹某個技巧，
也不是為了推廣一種寫法。

它存在的原因很單純：

> **有些設計，如果不被寫下來，  
> 很快就會在實作與重構中失去原本的形狀。**

這一章，並不是結論，
而是為整套設計留下「存在理由」。

---

## 這不是一套追求完整性的設計

在閱讀這份手稿時，
很容易注意到一件事：

- 有些概念只有語意，沒有型別
- 有些角色刻意保持「不聰明」
- 有些問題被明確地「沒有建模」

這不是疏忽，
而是刻意的選擇。

這套設計關心的從來不是：
> 「是否什麼都想好了？」

而是：
> **「哪些東西不應該現在就被想完？」**

---

## 為什麼 `WritePlan` 沒有成為一個型別

在許多設計中，
「計畫（Plan）」會很自然地被實作成一個 class。

但在這裡，
`WritePlan` 被刻意內建進 `WriteOperation.chain(..)` 之中。

這代表一個立場：

- 組合完成的行為，本身就應該是一個行為
- 不需要額外的承載結構來證明它的存在
- 語意應該被壓縮，而不是被展開

這讓設計保持輕盈，
也讓未來的演進保有彈性。

---

## 為什麼 Pipeline 被設計得「很笨」

在實作層面，
Pipeline 可能是整套系統中最簡單的元件。

它不理解業務，
不理解條件，
甚至不理解行為的意義。

這不是偷懶，
而是一種保護機制。

> **只要 Pipeline 足夠笨，  
> 行為語言就不會被它吞噬。**

---

## 為什麼 Builder 與 Behavior 必須斷軸

將 `GeneralBuilder` 與 `TransformStep` 明確分屬兩條軸線，
並不是為了分類整齊，
而是為了避免一個常見的結局：

- Builder 開始做事
- Step 開始建構東西
- Context 變成萬用袋

一旦這件事發生，
系統就會回到一個熟悉但難以維護的狀態。

這份文件反覆強調邊界，
不是因為邊界本身很重要，
而是因為**沒有邊界的設計，無法長期存在**。

---

## 這份手稿希望被怎麼使用

這份文件並不期待被「照抄」。

它比較適合被用來：

- 在設計卡關時，回來確認角色是否越界
- 在重構時，檢查複雜度是否跑錯位置
- 在解釋設計時，說清楚「我們為什麼不這樣做」

它是一份參考座標，
而不是規格書。

---

## 關於未來的演進

這套設計刻意留下空間給未來：

- 也許有一天需要顯式的 WritePlan
- 也許需要更多型別來描述組合結果
- 也許行為模型會被拆得更細

這些都不違背目前的設計，
前提只有一個：

> **新的抽象，必須站在正確的軸線上出現。**

---

## 最後的一句話

如果這份手稿只留下任何一句話，
那應該是這一句：

> **不要急著把所有東西都變成型別，  
> 先確定你想保護的是哪一種複雜度。**

只要這個問題還被記得，
這套設計就還活著。
