# 物件建構（Object Construction）與行為轉換（Behavior）的邊界

在前面的章節中，我們已經分別討論了：

- `GeneralBuilder`：用來組合並產生新物件
- `TransformStep`：在 `StepContext<T>` 上運行的行為節點
- `WriteOperation`：描述狀態改變的最小行為語言

如果這些角色沒有被放在正確的邊界上理解，
整個設計很容易在實作過程中再次塌縮成
「什麼都往同一個抽象裡塞」。

本章的目的，就是**正式劃出兩條不可混用的軸線**。

---

## 兩條軸線，而不是同一條流程

一個常見的誤解是：
把「建構」與「行為」視為同一條流程的不同階段。

在本設計中，這個理解是錯的。

我們面對的是兩條**性質不同的抽象軸線**：

- **物件建構（Object Construction）**
- **行為轉換（Behavior / Transformation）**

它們解決的是不同問題，
也必須由不同角色負責。

---

## 軸線一：物件建構（Object Construction）

物件建構關心的是：

- 要產生什麼樣的物件
- 這個物件由哪些構件組成
- 初始化規則如何被描述與組合

在這條軸線上：

- 時間性不重要
- 成功或失敗不重要
- 執行順序不是語意的一部分

重要的是：
> **建構結果看起來是什麼樣子。**

`GeneralBuilder` 正是屬於這條軸線。

---

### `GeneralBuilder` 的世界觀

在 Object Construction 的世界裡：

- 沒有 `StepContext`
- 沒有 Validation
- 沒有短路或流程控制

只有：
- 組合
- 選擇
- 產生新物件

一旦建構完成，
這個結果就可以被交給任何其他機制使用，
而不再回頭影響建構本身。

---

## 軸線二：行為轉換（Behavior / Transformation）

行為轉換關心的是：

- 已存在的狀態如何被一步步改變
- 行為是否成功
- 是否需要中斷後續處理
- 錯誤如何被傳遞

在這條軸線上：

- 時間性是核心
- 成敗會影響後續行為
- 行為必須被串接與短路

`TransformStep` 正是這條軸線的基本單位。

---

### `TransformStep` 的世界觀

在 Behavior 的世界裡：

- 輸入與輸出都是 `StepContext<T>`
- 每一步都可能失敗
- 失敗會中斷後續行為

因此，`TransformStep` 的型別語意自然趨近於：

`StepContext<T> -> Validation<Violations, StepContext<T>>`

這是一個典型的高階行為轉換模型，
與物件建構無關。

---

## 為什麼這兩條軸線不能混用

如果把這兩條軸線混在一起，
常見的後果包括：

- Builder 開始知道 pipeline
- 行為 step 開始產生新物件
- context 被拿來做建構用途
- 初始化與執行邏輯糾纏在一起

結果通常是：
- 抽象變得難以理解
- 修改任一邊都牽動另一邊
- 系統失去長期穩定性

---

## `WriteOperation` 所處的位置

`WriteOperation` 是一個容易被誤會的角色，
因為它同時會出現在兩條軸線附近。

正確的理解是：

- `WriteOperation` 是**行為語言**
- 它可以被用來：
  - 描述物件初始化的一部分（在建構完成後才執行）
  - 描述行為流程中的狀態改變

但它本身不決定：
- 何時被執行
- 是否要短路
- 是否屬於某條流程

這些都由所屬的軸線決定。

---

## 一個判斷準則（實作時非常有用）

在實作或重構時，
可以用以下問題來判斷該放在哪條軸線：

- 「這段邏輯是在**產生一個新東西**嗎？」
  → Object Construction
- 「這段邏輯是在**改變既有狀態**嗎？」
  → Behavior / Transformation

如果同一段程式碼同時回答了兩個問題，
那幾乎可以確定邊界被破壞了。

---

## 邊界不是限制，而是保護

劃清這條邊界，
並不是為了限制設計的自由度，
而是為了保護系統免於：

- 抽象過載
- 職責漂移
- 不可預期的耦合

當物件建構與行為轉換各自站穩位置，
系統才能在演進中維持清晰。

---

## 一句話總結

> **物件建構決定「世界長什麼樣子」，  
> 行為轉換決定「世界如何發生變化」。**

只要這條界線被守住，
其他設計選擇就有足夠的空間自由演化。

