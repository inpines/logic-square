# `WriteOperation 設計手稿`

這份文件是一套以 **`WriteOperation` 作為核心語言單位** 的轉換與組裝設計手稿。

它不是 API 文件，也不是操作教學，
而是用來說明一個更根本的問題：

> **當我們在描述「資料被如何改變或轉換」時，  
> 是否能用一種比流程、步驟或框架更穩定的語言？**

本手稿嘗試回答這個問題。

---

## 本文件在談什麼

這裡關注的不是「怎麼寫程式比較快」，  
而是「**行為應該如何被描述、被組合、被重用**」。

核心立場如下：

- **`WriteOperation` 是最小且可推理的行為單位**
- **`GeneralBuilder` 只是用來組接 `WriteOperation` 的語法工具**
- **`Transform / Pipeline` 不擁有語意，只承載執行**
- 所有複雜度，應該被壓縮在「可組合的操作語言」中，而不是流程控制裡

---

## 為什麼不是 Step、Handler 或 Pipeline

在多數系統中，轉換邏輯往往會逐漸滑向：

- 巨大的 `if–else`
- 吃滿語意的 `pipeline`
- 隨著需求膨脹而失控的 `step abstraction`

本設計刻意避開這條路，  
轉而將焦點放在「**寫入這個動作本身**」。

這不是一種技巧選擇，而是一種語言選擇。

---

## 文件結構

### 動機與背景
- 為什麼選擇 `WriteOperation` 作為核心
- 為什麼刻意壓薄 `Step` 與 `Pipeline`

### 核心抽象
- `WriteOperation` 是什麼、不是什麼
- `GeneralBuilder` 的責任邊界
- `TransformStep` 為何只是 Adapter

### 組裝與流程
- `WritePlan` 的形成方式
- 條件式組合的語意
- `Pipeline` 如何「不思考，只執行」

### 邊界與取捨
- Builder 不該做的事
- Transform 不該擁有的權力
- 為何這些限制是必要的

---

## 如何閱讀這份手稿

這份文件**不需要從頭到尾一次看完**。

它被設計成：
- 可以跳讀
- 可以反覆回來查某個觀念
- 可以隨著實作一起演進

如果你在設計中曾經對「流程變複雜卻難以推理」感到不安，
那這份手稿很可能會對你有用。

---

## 狀態說明

這是一份 **持續演進中的設計手稿**。

內容可能會：
- 調整措辭
- 收斂概念
- 修正早期假設

但核心立場會盡量保持穩定。

---

> 本文件的目的，不是給出標準答案，  
> 而是提供一種 **可以長期承載複雜度的描述方式**。
