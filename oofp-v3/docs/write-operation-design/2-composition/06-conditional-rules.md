# 條件式組合（Conditional Rules）

在本設計中，條件式（`condition`）**不是流程控制**，
也不是某個階段才會被「評估完成」的判斷。

條件式是 **`WriteOperation` 語言本身的一部分**。

更精確地說：

> **條件是一種可組合的 predicate，  
> 用來改變 writer 的組裝方式與行為語意。**

---

## 條件不是「要不要執行」

一個常見但錯誤的理解是：

> 條件的作用是決定某個行為「要不要被執行」。

這種理解，會立刻把條件拉回流程語言：

```java
if (cond) {
  op.write(target);
}
````

但在本設計中，這種寫法是被刻意避免的，  
因為它把條件放在「執行時流程控制」的位置。

---

## 條件是 writer 的組合語意

在這套模型裡，條件的角色是：

> **描述一個 `WriteOperation` 在什麼情境下，  
> 以什麼方式影響 target。**

因此：

- 條件不是外掛在 chain 之外
    
- 條件不負責決定「是否存在這個 writer」
    
- 條件是 **writer 本身的行為修飾子**
    

換句話說：

> **`WriteOperation` 可以攜帶條件，  
> 而不是被條件包住。**

---

## Conditional = 可組合的 predicate

在語意上，條件可以理解為：

- 一種 predicate
    
- 可被組合（and / or / not）
    
- 可被 chain 進 writer
    
- 與 writer 一起被延後運算
    

因此，一個 `composite WriteOperation` 可能包含：

- 多個寫入行為
    
- 多層條件語意
    
- 不同條件下的不同行為表現
    

而這些都不需要在「組合階段」被提前決定。

---

## chain(..) 不等於「條件已被評估」

`WriteOperation.chain(..)` 的意義是：

> **將多個行為與其條件語意，  
> 組合成一個可重用的複合 writer。**

它並不代表：

- 條件已經被求值
    
- 行為是否會發生已被決定
    
- 組合結果已「固化成無條件行為」
    

相反地，chain 的結果仍然是：

> **攜帶條件語意、等待被觸發的行為描述。**

---

## `GeneralBuilder` 與條件的關係

`GeneralBuilder` 可能會參與條件的**宣告與組裝**，  
但它並不擁有條件的語意主權。

它做的是：

- 宣告哪些 writer 被組合
    
- 宣告這些 writer 如何攜帶條件
    
- 產生一個複合 writer 作為結果
    

但：

- 不評估條件
    
- 不消解 predicate
    
- 不決定行為是否實際發生
    

---

## `TransformStep` 與條件的關係

`TransformStep` 並不是條件判斷者，  
而是 **條件被實際套用的時刻**。

在行為發生的當下：

- writer 會根據其攜帶的 predicate
    
- 決定如何影響 target
    
- 或是否對 target 產生影響
    

`TransformStep` 只負責觸發，  
不負責解釋條件。

---

## 一個實作層的判斷準則

當你在設計條件時，可以問自己：

- 這個條件是在描述「行為如何發生」？  
    → 應該是 `WriteOperation` 的一部分
    
- 還是在描述「流程是否繼續」？  
    → 才屬於 `Validation / BehaviorStep`
    

如果條件影響的是 writer 的表現形式，  
那它就不該被抽離出行為語言。

---

## 一句話總結

> **條件式不是為了決定「要不要做」，  
> 而是為了描述「在什麼情境下，怎麼做」。**

因此，條件不是流程控制，  
而是行為語言的組合能力。

---
